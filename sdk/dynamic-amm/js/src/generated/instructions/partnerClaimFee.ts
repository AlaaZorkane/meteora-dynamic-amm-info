/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/web3.js';
import { AMM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const PARTNER_CLAIM_FEE_DISCRIMINATOR = new Uint8Array([
  57, 53, 176, 30, 123, 70, 52, 64,
]);

export function getPartnerClaimFeeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    PARTNER_CLAIM_FEE_DISCRIMINATOR
  );
}

export type PartnerClaimFeeInstruction<
  TProgram extends string = typeof AMM_PROGRAM_ADDRESS,
  TAccountPool extends string | IAccountMeta<string> = string,
  TAccountAVaultLp extends string | IAccountMeta<string> = string,
  TAccountProtocolTokenAFee extends string | IAccountMeta<string> = string,
  TAccountProtocolTokenBFee extends string | IAccountMeta<string> = string,
  TAccountPartnerTokenA extends string | IAccountMeta<string> = string,
  TAccountPartnerTokenB extends string | IAccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountPartnerAuthority extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountAVaultLp extends string
        ? ReadonlyAccount<TAccountAVaultLp>
        : TAccountAVaultLp,
      TAccountProtocolTokenAFee extends string
        ? WritableAccount<TAccountProtocolTokenAFee>
        : TAccountProtocolTokenAFee,
      TAccountProtocolTokenBFee extends string
        ? WritableAccount<TAccountProtocolTokenBFee>
        : TAccountProtocolTokenBFee,
      TAccountPartnerTokenA extends string
        ? WritableAccount<TAccountPartnerTokenA>
        : TAccountPartnerTokenA,
      TAccountPartnerTokenB extends string
        ? WritableAccount<TAccountPartnerTokenB>
        : TAccountPartnerTokenB,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountPartnerAuthority extends string
        ? ReadonlySignerAccount<TAccountPartnerAuthority> &
            IAccountSignerMeta<TAccountPartnerAuthority>
        : TAccountPartnerAuthority,
      ...TRemainingAccounts,
    ]
  >;

export type PartnerClaimFeeInstructionData = {
  discriminator: ReadonlyUint8Array;
  maxAmountA: bigint;
  maxAmountB: bigint;
};

export type PartnerClaimFeeInstructionDataArgs = {
  maxAmountA: number | bigint;
  maxAmountB: number | bigint;
};

export function getPartnerClaimFeeInstructionDataEncoder(): Encoder<PartnerClaimFeeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['maxAmountA', getU64Encoder()],
      ['maxAmountB', getU64Encoder()],
    ]),
    (value) => ({ ...value, discriminator: PARTNER_CLAIM_FEE_DISCRIMINATOR })
  );
}

export function getPartnerClaimFeeInstructionDataDecoder(): Decoder<PartnerClaimFeeInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['maxAmountA', getU64Decoder()],
    ['maxAmountB', getU64Decoder()],
  ]);
}

export function getPartnerClaimFeeInstructionDataCodec(): Codec<
  PartnerClaimFeeInstructionDataArgs,
  PartnerClaimFeeInstructionData
> {
  return combineCodec(
    getPartnerClaimFeeInstructionDataEncoder(),
    getPartnerClaimFeeInstructionDataDecoder()
  );
}

export type PartnerClaimFeeInput<
  TAccountPool extends string = string,
  TAccountAVaultLp extends string = string,
  TAccountProtocolTokenAFee extends string = string,
  TAccountProtocolTokenBFee extends string = string,
  TAccountPartnerTokenA extends string = string,
  TAccountPartnerTokenB extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountPartnerAuthority extends string = string,
> = {
  /** Pool account (PDA) */
  pool: Address<TAccountPool>;
  aVaultLp: Address<TAccountAVaultLp>;
  protocolTokenAFee: Address<TAccountProtocolTokenAFee>;
  protocolTokenBFee: Address<TAccountProtocolTokenBFee>;
  partnerTokenA: Address<TAccountPartnerTokenA>;
  partnerTokenB: Address<TAccountPartnerTokenB>;
  tokenProgram?: Address<TAccountTokenProgram>;
  partnerAuthority: TransactionSigner<TAccountPartnerAuthority>;
  maxAmountA: PartnerClaimFeeInstructionDataArgs['maxAmountA'];
  maxAmountB: PartnerClaimFeeInstructionDataArgs['maxAmountB'];
};

export function getPartnerClaimFeeInstruction<
  TAccountPool extends string,
  TAccountAVaultLp extends string,
  TAccountProtocolTokenAFee extends string,
  TAccountProtocolTokenBFee extends string,
  TAccountPartnerTokenA extends string,
  TAccountPartnerTokenB extends string,
  TAccountTokenProgram extends string,
  TAccountPartnerAuthority extends string,
  TProgramAddress extends Address = typeof AMM_PROGRAM_ADDRESS,
>(
  input: PartnerClaimFeeInput<
    TAccountPool,
    TAccountAVaultLp,
    TAccountProtocolTokenAFee,
    TAccountProtocolTokenBFee,
    TAccountPartnerTokenA,
    TAccountPartnerTokenB,
    TAccountTokenProgram,
    TAccountPartnerAuthority
  >,
  config?: { programAddress?: TProgramAddress }
): PartnerClaimFeeInstruction<
  TProgramAddress,
  TAccountPool,
  TAccountAVaultLp,
  TAccountProtocolTokenAFee,
  TAccountProtocolTokenBFee,
  TAccountPartnerTokenA,
  TAccountPartnerTokenB,
  TAccountTokenProgram,
  TAccountPartnerAuthority
> {
  // Program address.
  const programAddress = config?.programAddress ?? AMM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    pool: { value: input.pool ?? null, isWritable: true },
    aVaultLp: { value: input.aVaultLp ?? null, isWritable: false },
    protocolTokenAFee: {
      value: input.protocolTokenAFee ?? null,
      isWritable: true,
    },
    protocolTokenBFee: {
      value: input.protocolTokenBFee ?? null,
      isWritable: true,
    },
    partnerTokenA: { value: input.partnerTokenA ?? null, isWritable: true },
    partnerTokenB: { value: input.partnerTokenB ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    partnerAuthority: {
      value: input.partnerAuthority ?? null,
      isWritable: false,
    },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.aVaultLp),
      getAccountMeta(accounts.protocolTokenAFee),
      getAccountMeta(accounts.protocolTokenBFee),
      getAccountMeta(accounts.partnerTokenA),
      getAccountMeta(accounts.partnerTokenB),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.partnerAuthority),
    ],
    programAddress,
    data: getPartnerClaimFeeInstructionDataEncoder().encode(
      args as PartnerClaimFeeInstructionDataArgs
    ),
  } as PartnerClaimFeeInstruction<
    TProgramAddress,
    TAccountPool,
    TAccountAVaultLp,
    TAccountProtocolTokenAFee,
    TAccountProtocolTokenBFee,
    TAccountPartnerTokenA,
    TAccountPartnerTokenB,
    TAccountTokenProgram,
    TAccountPartnerAuthority
  >;

  return instruction;
}

export type ParsedPartnerClaimFeeInstruction<
  TProgram extends string = typeof AMM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    /** Pool account (PDA) */
    pool: TAccountMetas[0];
    aVaultLp: TAccountMetas[1];
    protocolTokenAFee: TAccountMetas[2];
    protocolTokenBFee: TAccountMetas[3];
    partnerTokenA: TAccountMetas[4];
    partnerTokenB: TAccountMetas[5];
    tokenProgram: TAccountMetas[6];
    partnerAuthority: TAccountMetas[7];
  };
  data: PartnerClaimFeeInstructionData;
};

export function parsePartnerClaimFeeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedPartnerClaimFeeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 8) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      pool: getNextAccount(),
      aVaultLp: getNextAccount(),
      protocolTokenAFee: getNextAccount(),
      protocolTokenBFee: getNextAccount(),
      partnerTokenA: getNextAccount(),
      partnerTokenB: getNextAccount(),
      tokenProgram: getNextAccount(),
      partnerAuthority: getNextAccount(),
    },
    data: getPartnerClaimFeeInstructionDataDecoder().decode(instruction.data),
  };
}
